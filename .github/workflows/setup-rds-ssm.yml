name: Setup RDS PostgreSQL + SSM Parameter Store

on:
  workflow_dispatch:
    inputs:
      db_username:
        description: 'RDS Master Username (default: postgres)'
        required: false
        default: 'postgres'
        type: string
      db_password:
        description: 'RDS Master Password (generate strong password)'
        required: true
        type: string
      db_instance_class:
        description: 'RDS Instance Class (default: db.t3.micro)'
        required: false
        default: 'db.t3.micro'
        type: string

permissions:
  id-token: write
  contents: read

jobs:
  setup-rds-ssm:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::055357411476:role/ifd-github-deploy
          aws-region: us-east-2

      - name: Get Latest PostgreSQL Version
        id: pg_version
        run: |
          PG_VERSION=$(aws rds describe-db-engine-versions \
            --engine postgres \
            --query 'DBEngineVersions[0].EngineVersion' \
            --output text \
            --region us-east-2)
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT
          echo "PostgreSQL version: $PG_VERSION"

      - name: Get VPC and Security Group Info
        id: vpc_info
        run: |
          # Get default VPC
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=isDefault,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region us-east-2)
          
          # Get subnets in default VPC
          SUBNET_IDS=$(aws ec2 describe-subnets \
            --filters "Name=vpc-id,Values=$VPC_ID" \
            --query 'Subnets[*].SubnetId' \
            --output text \
            --region us-east-2)
          
          # Get security group for EC2 instance
          INSTANCE_ID="i-0160b2a838a432bbc"
          INSTANCE_SG=$(aws ec2 describe-instances \
            --instance-ids "$INSTANCE_ID" \
            --query 'Reservations[0].Instances[0].SecurityGroups[0].GroupId' \
            --output text \
            --region us-east-2)
          
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "subnet_ids=$SUBNET_IDS" >> $GITHUB_OUTPUT
          echo "instance_sg=$INSTANCE_SG" >> $GITHUB_OUTPUT
          
          echo "VPC ID: $VPC_ID"
          echo "Subnet IDs: $SUBNET_IDS"
          echo "Instance Security Group: $INSTANCE_SG"

      - name: Create RDS Security Group
        id: rds_sg
        run: |
          VPC_ID="${{ steps.vpc_info.outputs.vpc_id }}"
          INSTANCE_SG="${{ steps.vpc_info.outputs.instance_sg }}"
          
          # Check if security group already exists
          EXISTING_SG=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=ifd-rds-postgres" "Name=vpc-id,Values=$VPC_ID" \
            --query 'SecurityGroups[0].GroupId' \
            --output text \
            --region us-east-2 || echo "None")
          
          if [[ "$EXISTING_SG" != "None" && "$EXISTING_SG" != "" ]]; then
            echo "Security group already exists: $EXISTING_SG"
            echo "sg_id=$EXISTING_SG" >> $GITHUB_OUTPUT
          else
            # Create security group
            SG_ID=$(aws ec2 create-security-group \
              --group-name ifd-rds-postgres \
              --description "Security group for Iron Front Digital RDS PostgreSQL" \
              --vpc-id "$VPC_ID" \
              --query 'GroupId' \
              --output text \
              --region us-east-2)
            
            echo "Created security group: $SG_ID"
            echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
            
            # Allow inbound from EC2 instance security group
            aws ec2 authorize-security-group-ingress \
              --group-id "$SG_ID" \
              --protocol tcp \
              --port 5432 \
              --source-group "$INSTANCE_SG" \
              --region us-east-2 || echo "Rule may already exist"
          fi

      - name: Create RDS PostgreSQL Instance
        id: rds_instance
        env:
          DB_USERNAME: ${{ github.event.inputs.db_username || 'postgres' }}
          DB_PASSWORD: ${{ github.event.inputs.db_password }}
          DB_INSTANCE_CLASS: ${{ github.event.inputs.db_instance_class || 'db.t3.micro' }}
        run: |
          set -euo pipefail
          
          DB_IDENTIFIER="ifd-postgres"
          VPC_ID="${{ steps.vpc_info.outputs.vpc_id }}"
          SG_ID="${{ steps.rds_sg.outputs.sg_id }}"
          PG_VERSION="${{ steps.pg_version.outputs.version }}"
          
          # Check if instance already exists
          EXISTING=$(aws rds describe-db-instances \
            --db-instance-identifier "$DB_IDENTIFIER" \
            --query 'DBInstances[0].DBInstanceStatus' \
            --output text \
            --region us-east-2 2>/dev/null || echo "None")
          
          if [[ "$EXISTING" != "None" && "$EXISTING" != "" ]]; then
            echo "RDS instance already exists with status: $EXISTING"
            if [[ "$EXISTING" != "available" ]]; then
              echo "Waiting for instance to be available..."
              aws rds wait db-instance-available \
                --db-instance-identifier "$DB_IDENTIFIER" \
                --region us-east-2 || true
            fi
          else
            echo "Creating RDS instance: $DB_IDENTIFIER"
            echo "Instance class: $DB_INSTANCE_CLASS"
            echo "PostgreSQL version: $PG_VERSION"
            
            # Create RDS instance
            aws rds create-db-instance \
              --db-instance-identifier "$DB_IDENTIFIER" \
              --db-instance-class "$DB_INSTANCE_CLASS" \
              --engine postgres \
              --engine-version "$PG_VERSION" \
              --master-username "$DB_USERNAME" \
              --master-user-password "$DB_PASSWORD" \
              --allocated-storage 20 \
              --storage-type gp2 \
              --db-name ironfront \
              --vpc-security-group-ids "$SG_ID" \
              --db-subnet-group-name default \
              --publicly-accessible \
              --backup-retention-period 7 \
              --no-multi-az \
              --region us-east-2
            
            echo "Waiting for RDS instance to be available (this may take 5-10 minutes)..."
            aws rds wait db-instance-available \
              --db-instance-identifier "$DB_IDENTIFIER" \
              --region us-east-2 || echo "Instance may still be creating"
          fi
          
          # Get endpoint
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier "$DB_IDENTIFIER" \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text \
            --region us-east-2)
          
          echo "db_endpoint=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "RDS endpoint: $ENDPOINT"

      - name: Construct and Store DATABASE_URL in SSM
        id: store_ssm
        env:
          DB_USERNAME: ${{ github.event.inputs.db_username || 'postgres' }}
          DB_PASSWORD: ${{ github.event.inputs.db_password }}
        run: |
          set -euo pipefail
          
          ENDPOINT="${{ steps.rds_instance.outputs.db_endpoint }}"
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${ENDPOINT}:5432/ironfront"
          
          SSM_PARAM="/ironfront/prod/DATABASE_URL"
          
          echo "Storing DATABASE_URL in SSM Parameter Store: $SSM_PARAM"
          
          # Check if parameter exists
          if aws ssm get-parameter --name "$SSM_PARAM" --region us-east-2 >/dev/null 2>&1; then
            echo "Parameter exists, updating..."
            aws ssm put-parameter \
              --name "$SSM_PARAM" \
              --value "$DATABASE_URL" \
              --type SecureString \
              --overwrite \
              --region us-east-2
          else
            echo "Parameter does not exist, creating..."
            aws ssm put-parameter \
              --name "$SSM_PARAM" \
              --value "$DATABASE_URL" \
              --type SecureString \
              --description "PostgreSQL connection string for Iron Front Digital production" \
              --region us-east-2
          fi
          
          echo "✅ DATABASE_URL stored in SSM Parameter Store"
          echo "Parameter name: $SSM_PARAM"
          echo "::add-mask::$DATABASE_URL"

      - name: Run Database Migrations
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
        run: |
          set -euo pipefail
          
          echo "Running database migrations..."
          
          SSM_PARAM="/ironfront/prod/DATABASE_URL"
          MIGRATION_SQL=$(cat operator-ui/prisma/migrations/20250116000000_add_auth_tables/migration.sql | base64 -w 0)
          
          CMD_ID=$(aws ssm send-command \
            --region us-east-2 \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"set -euo pipefail\",
              \"echo 'Retrieving DATABASE_URL from SSM...'\",
              \"DATABASE_URL=\\\$(aws ssm get-parameter --name $SSM_PARAM --with-decryption --query Parameter.Value --output text --region us-east-2)\",
              \"if [ -z \\\"\\\$DATABASE_URL\\\" ]; then\",
              \"  echo '❌ Failed to retrieve DATABASE_URL from SSM'\",
              \"  exit 1\",
              \"fi\",
              \"echo 'Installing postgresql client...'\",
              \"sudo yum install -y postgresql15 || sudo apt-get update && sudo apt-get install -y postgresql-client || echo 'Client install skipped'\",
              \"echo 'Testing connection...'\",
              \"if psql \\\"\\\$DATABASE_URL\\\" -c 'SELECT 1' >/dev/null 2>&1; then\",
              \"  echo '✅ Connection successful'\",
              \"else\",
              \"  echo '❌ Connection failed - RDS may still be initializing'\",
              \"  echo 'Waiting 30 seconds and retrying...'\",
              \"  sleep 30\",
              \"  psql \\\"\\\$DATABASE_URL\\\" -c 'SELECT 1' || exit 1\",
              \"fi\",
              \"echo 'Applying migration...'\",
              \"cd /tmp\",
              \"echo '$MIGRATION_SQL' | base64 -d > migration.sql\",
              \"if psql \\\"\\\$DATABASE_URL\\\" -f migration.sql; then\",
              \"  echo '✅ Migration applied successfully'\",
              \"else\",
              \"  echo '❌ Migration failed'\",
              \"  exit 1\",
              \"fi\",
              \"echo 'Verifying tables...'\",
              \"TABLES=\\\$(psql \\\"\\\$DATABASE_URL\\\" -t -c \\\"SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename IN ('users', 'magic_links', 'sessions', 'events');\\\" | tr -d ' ')\",
              \"for table in users magic_links sessions events; do\",
              \"  if echo \\\"\\\$TABLES\\\" | grep -q \\\"^\\\$table\\$\"; then\",
              \"    echo \\\"✅ Table \\\$table exists\\\"\",
              \"  else\",
              \"    echo \\\"❌ Table \\\$table missing\\\"\",
              \"    exit 1\",
              \"  fi\",
              \"done\",
              \"echo '✅ All tables verified'\"
            ]" \
            --comment "IFD run RDS migrations from SSM" \
            --query "Command.CommandId" \
            --output text)
          
          echo "Waiting for migrations..."
          sleep 15
          
          aws ssm wait command-executed \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" || true
          
          OUTPUT=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)
          
          STATUS=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text)
          
          echo "Migration Status: $STATUS"
          echo "$OUTPUT"
          
          if [[ "$STATUS" != "Success" ]]; then
            ERROR=$(aws ssm get-command-invocation \
              --region us-east-2 \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text)
            echo "Error: $ERROR"
            exit 1
          fi

      - name: Final Summary
        run: |
          echo "=========================================="
          echo "✅ RDS Setup Complete!"
          echo "=========================================="
          echo ""
          echo "RDS Instance: ifd-postgres"
          echo "Endpoint: ${{ steps.rds_instance.outputs.db_endpoint }}"
          echo "SSM Parameter: /ironfront/prod/DATABASE_URL"
          echo ""
          echo "Next steps:"
          echo "1. Redeploy using 'Deploy to Iron Front Digital (Prod)' workflow"
          echo "2. The deploy script will automatically read DATABASE_URL from SSM"
          echo "3. Test login at https://ironfrontdigital.com/login"

