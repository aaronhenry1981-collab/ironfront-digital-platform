name: Run Complete RDS Setup (Via SSM)

on:
  workflow_dispatch:
    inputs:
      db_password:
        description: 'RDS Master Password (generate strong password)'
        required: true
        type: string
        default: 'IronFront2024!SecureRDS#Postgres'

permissions:
  id-token: write
  contents: read

jobs:
  setup-rds:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::055357411476:role/ifd-github-deploy
          aws-region: us-east-2

      - name: Get VPC and Security Group Info
        id: vpc_info
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
        run: |
          set -euo pipefail
          
          echo "Getting VPC and security group info using EC2 instance metadata..."
          
          # Use EC2 instance metadata service (simplified commands to avoid syntax errors)
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"TOKEN=\\\$(curl -s -X PUT http://169.254.169.254/latest/api/token -H X-aws-ec2-metadata-token-ttl-seconds:21600)\",
              \"MAC=\\\$(curl -s -H X-aws-ec2-metadata-token:\\\$TOKEN http://169.254.169.254/latest/meta-data/network/interfaces/macs/ | head -1)\",
              \"VPC_ID=\\\$(curl -s -H X-aws-ec2-metadata-token:\\\$TOKEN http://169.254.169.254/latest/meta-data/network/interfaces/macs/\\\$MAC/vpc-id)\",
              \"INSTANCE_SG=\\\$(curl -s -H X-aws-ec2-metadata-token:\\\$TOKEN http://169.254.169.254/latest/meta-data/network/interfaces/macs/\\\$MAC/security-groups | head -1)\",
              \"echo VPC_ID=\\\$VPC_ID\",
              \"echo INSTANCE_SG=\\\$INSTANCE_SG\"
            ]" \
            --region us-east-2 \
            --query "Command.CommandId" \
            --output text)
          
          echo "Waiting for SSM command to complete..."
          sleep 8
          
          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 2>&1 || echo "Command completed"
          
          # Get output
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 \
            --query "StandardOutputContent" \
            --output text 2>/dev/null || echo "")
          
          ERROR=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 \
            --query "StandardErrorContent" \
            --output text 2>/dev/null || echo "")
          
          STATUS=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 \
            --query "Status" \
            --output text 2>/dev/null || echo "Unknown")
          
          echo "SSM Command Status: $STATUS"
          echo "SSM Output:"
          echo "$OUTPUT"
          if [[ -n "$ERROR" ]]; then
            echo "SSM Error:"
            echo "$ERROR"
          fi
          
          # Parse VPC ID and instance security group from output
          VPC_ID=$(echo "$OUTPUT" | grep -E "^VPC_ID=" | cut -d'=' -f2- | tr -d '\n\r ' || echo "")
          INSTANCE_SG=$(echo "$OUTPUT" | grep -E "^INSTANCE_SG=" | cut -d'=' -f2- | tr -d '\n\r ' || echo "")
          
          # Validate
          if [[ -z "$VPC_ID" || ! "$VPC_ID" =~ ^vpc- ]]; then
            echo "❌ Failed to get valid VPC ID from metadata"
            echo "VPC_ID: '$VPC_ID'"
            echo "Trying alternative method (RDS subnet group)..."
            
            # Alternative: Try to get from RDS default subnet group (if it exists)
            VPC_ID=$(aws rds describe-db-subnet-groups \
              --db-subnet-group-name default \
              --query 'DBSubnetGroups[0].VpcId' \
              --output text \
              --region us-east-2 2>/dev/null || echo "")
            
            if [[ -z "$VPC_ID" || "$VPC_ID" == "None" || ! "$VPC_ID" =~ ^vpc- ]]; then
              echo "❌ Still failed to get VPC ID"
              exit 1
            fi
            echo "✅ Got VPC ID from RDS subnet group: $VPC_ID"
          fi
          
          if [[ -z "$INSTANCE_SG" || ! "$INSTANCE_SG" =~ ^sg- ]]; then
            echo "❌ Failed to get valid instance security group from metadata"
            echo "INSTANCE_SG: '$INSTANCE_SG'"
            echo "Trying alternative method (AWS CLI via SSM)..."
            
            # Alternative: Try via AWS CLI (if available)
            CMD_ID2=$(aws ssm send-command \
              --instance-ids "$INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --parameters commands="[
                \"INSTANCE_SG=\\\$(aws ec2 describe-instances --instance-ids $INSTANCE_ID --query Reservations[0].Instances[0].SecurityGroups[0].GroupId --output text --region us-east-2 2>/dev/null || echo)\",
                \"echo INSTANCE_SG=\\\$INSTANCE_SG\"
              ]" \
              --region us-east-2 \
              --query "Command.CommandId" \
              --output text)
            
            sleep 5
            aws ssm wait command-executed \
              --command-id "$CMD_ID2" \
              --instance-id "$INSTANCE_ID" \
              --region us-east-2 2>&1 || true
            
            OUTPUT2=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID2" \
              --instance-id "$INSTANCE_ID" \
              --region us-east-2 \
              --query "StandardOutputContent" \
              --output text 2>/dev/null || echo "")
            
            INSTANCE_SG=$(echo "$OUTPUT2" | grep -E "^INSTANCE_SG=" | cut -d'=' -f2- | tr -d '\n\r ' || echo "")
            
            if [[ -z "$INSTANCE_SG" || ! "$INSTANCE_SG" =~ ^sg- ]]; then
              echo "❌ Still failed to get instance security group"
              exit 1
            fi
            echo "✅ Got instance security group via AWS CLI: $INSTANCE_SG"
          fi
          
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "instance_sg=$INSTANCE_SG" >> $GITHUB_OUTPUT
          
          echo "✅ VPC ID: $VPC_ID"
          echo "✅ Instance Security Group: $INSTANCE_SG"

      - name: Create RDS Security Group
        id: rds_sg
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
        run: |
          set -euo pipefail
          
          VPC_ID="${{ steps.vpc_info.outputs.vpc_id }}"
          INSTANCE_SG="${{ steps.vpc_info.outputs.instance_sg }}"
          
          echo "Creating/checking RDS security group via SSM (EC2 instance has permissions)..."
          
          # Use SSM to create security group (EC2 instance role has EC2 permissions)
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"set -euo pipefail\",
              \"VPC_ID='$VPC_ID'\",
              \"INSTANCE_SG='$INSTANCE_SG'\",
              \"EXISTING_SG=\\\$(aws ec2 describe-security-groups --filters Name=group-name,Values=ifd-rds-postgres Name=vpc-id,Values=\\\$VPC_ID --query 'SecurityGroups[0].GroupId' --output text --region us-east-2 2>/dev/null || echo 'None')\",
              \"if [ \\\"\\\$EXISTING_SG\\\" != 'None' ] && [ -n \\\"\\\$EXISTING_SG\\\" ]; then\",
              \"  echo \\\"\\\$EXISTING_SG\\\"\",
              \"  echo 'Security group already exists: '\\\$EXISTING_SG\",
              \"else\",
              \"  SG_ID=\\\$(aws ec2 create-security-group --group-name ifd-rds-postgres --description 'Security group for Iron Front Digital RDS PostgreSQL' --vpc-id \\\$VPC_ID --query 'GroupId' --output text --region us-east-2)\",
              \"  echo \\\"\\\$SG_ID\\\"\",
              \"  echo 'Created security group: '\\\$SG_ID\",
              \"  aws ec2 authorize-security-group-ingress --group-id \\\$SG_ID --protocol tcp --port 5432 --source-group \\\$INSTANCE_SG --region us-east-2 2>/dev/null || echo 'Rule may already exist'\",
              \"fi\"
            ]" \
            --region us-east-2 \
            --query "Command.CommandId" \
            --output text)
          
          sleep 5
          aws ssm wait command-executed \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 || true
          
          OUTPUT=$(aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --region us-east-2 \
            --query "StandardOutputContent" \
            --output text)
          
          # Extract security group ID (last line that looks like sg-xxxxx)
          SG_ID=$(echo "$OUTPUT" | grep -oE 'sg-[a-z0-9]+' | tail -1)
          
          if [[ -z "$SG_ID" ]]; then
            echo "❌ Failed to get/create security group"
            echo "Output: $OUTPUT"
            exit 1
          fi
          
          echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
          echo "✅ Security Group: $SG_ID"
          echo "$OUTPUT"

      - name: Get Latest PostgreSQL Version
        id: pg_version
        run: |
          PG_VERSION=$(aws rds describe-db-engine-versions \
            --engine postgres \
            --query 'DBEngineVersions[0].EngineVersion' \
            --output text \
            --region us-east-2)
          echo "version=$PG_VERSION" >> $GITHUB_OUTPUT
          echo "PostgreSQL version: $PG_VERSION"

      - name: Create RDS PostgreSQL Instance
        id: rds_instance
        env:
          DB_USERNAME: postgres
          DB_PASSWORD: ${{ github.event.inputs.db_password }}
          DB_INSTANCE_CLASS: db.t3.micro
        run: |
          set -euo pipefail
          
          DB_IDENTIFIER="ifd-postgres"
          SG_ID="${{ steps.rds_sg.outputs.sg_id }}"
          PG_VERSION="${{ steps.pg_version.outputs.version }}"
          
          # Check if instance already exists
          EXISTING_STATUS=$(aws rds describe-db-instances \
            --db-instance-identifier "$DB_IDENTIFIER" \
            --query 'DBInstances[0].DBInstanceStatus' \
            --output text \
            --region us-east-2 2>/dev/null || echo "None")
          
          if [[ "$EXISTING_STATUS" != "None" && "$EXISTING_STATUS" != "" ]]; then
            echo "RDS instance already exists with status: $EXISTING_STATUS"
            if [[ "$EXISTING_STATUS" != "available" ]]; then
              echo "Waiting for instance to be available..."
              aws rds wait db-instance-available \
                --db-instance-identifier "$DB_IDENTIFIER" \
                --region us-east-2 || echo "Still initializing..."
            fi
          else
            echo "Creating RDS instance: $DB_IDENTIFIER"
            echo "This will take 5-10 minutes..."
            
            aws rds create-db-instance \
              --db-instance-identifier "$DB_IDENTIFIER" \
              --db-instance-class "$DB_INSTANCE_CLASS" \
              --engine postgres \
              --engine-version "$PG_VERSION" \
              --master-username "$DB_USERNAME" \
              --master-user-password "$DB_PASSWORD" \
              --allocated-storage 20 \
              --storage-type gp2 \
              --db-name ironfront \
              --vpc-security-group-ids "$SG_ID" \
              --db-subnet-group-name default \
              --publicly-accessible \
              --backup-retention-period 7 \
              --no-multi-az \
              --region us-east-2
            
            echo "Waiting for RDS to be available (this takes 5-10 minutes)..."
            aws rds wait db-instance-available \
              --db-instance-identifier "$DB_IDENTIFIER" \
              --region us-east-2 || echo "Instance may still be initializing"
          fi
          
          # Get endpoint
          ENDPOINT=$(aws rds describe-db-instances \
            --db-instance-identifier "$DB_IDENTIFIER" \
            --query 'DBInstances[0].Endpoint.Address' \
            --output text \
            --region us-east-2)
          
          echo "db_endpoint=$ENDPOINT" >> $GITHUB_OUTPUT
          echo "RDS Endpoint: $ENDPOINT"

      - name: Store DATABASE_URL in SSM Parameter Store
        id: store_ssm
        env:
          DB_USERNAME: postgres
          DB_PASSWORD: ${{ github.event.inputs.db_password }}
        run: |
          set -euo pipefail
          
          ENDPOINT="${{ steps.rds_instance.outputs.db_endpoint }}"
          DATABASE_URL="postgresql://${DB_USERNAME}:${DB_PASSWORD}@${ENDPOINT}:5432/ironfront"
          
          SSM_PARAM="/ironfront/prod/DATABASE_URL"
          
          echo "Storing DATABASE_URL in SSM Parameter Store: $SSM_PARAM"
          
          # Check if parameter exists
          if aws ssm get-parameter --name "$SSM_PARAM" --region us-east-2 >/dev/null 2>&1; then
            echo "Parameter exists, updating..."
            aws ssm put-parameter \
              --name "$SSM_PARAM" \
              --value "$DATABASE_URL" \
              --type SecureString \
              --overwrite \
              --region us-east-2 >/dev/null
          else
            echo "Parameter does not exist, creating..."
            aws ssm put-parameter \
              --name "$SSM_PARAM" \
              --value "$DATABASE_URL" \
              --type SecureString \
              --description "PostgreSQL connection string for Iron Front Digital production" \
              --region us-east-2 >/dev/null
          fi
          
          echo "✅ DATABASE_URL stored in SSM Parameter Store"
          echo "::add-mask::$DATABASE_URL"

      - name: Run Database Migrations
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
          DATABASE_URL: ${{ steps.store_ssm.outputs.DATABASE_URL }}
        run: |
          set -euo pipefail
          
          echo "Running database migrations..."
          
          # Get DATABASE_URL from SSM (for the script on EC2)
          SSM_PARAM="/ironfront/prod/DATABASE_URL"
          DB_URL=$(aws ssm get-parameter \
            --name "$SSM_PARAM" \
            --with-decryption \
            --query Parameter.Value \
            --output text \
            --region us-east-2)
          
          MIGRATION_SQL=$(cat operator-ui/prisma/migrations/20250116000000_add_auth_tables/migration.sql | base64 -w 0)
          
          CMD_ID=$(aws ssm send-command \
            --region us-east-2 \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"set -euo pipefail\",
              \"echo 'Installing postgresql client...'\",
              \"sudo yum install -y postgresql15 >/dev/null 2>&1 || sudo apt-get update >/dev/null 2>&1 && sudo apt-get install -y postgresql-client >/dev/null 2>&1 || echo 'Client install skipped'\",
              \"echo 'Testing connection...'\",
              \"DB_URL='$DB_URL'\",
              \"for i in {1..6}; do\",
              \"  if psql \\\"\\\$DB_URL\\\" -c 'SELECT 1' >/dev/null 2>&1; then\",
              \"    echo '✅ Connection successful'\",
              \"    break\",
              \"  else\",
              \"    if [ \\\$i -eq 6 ]; then\",
              \"      echo '❌ Connection failed after 6 attempts'\",
              \"      exit 1\",
              \"    fi\",
              \"    echo 'Waiting for RDS to be ready... (attempt '\\\$i'/6)'\",
              \"    sleep 10\",
              \"  fi\",
              \"done\",
              \"echo 'Applying migration...'\",
              \"cd /tmp\",
              \"echo '$MIGRATION_SQL' | base64 -d > migration.sql\",
              \"if psql \\\"\\\$DB_URL\\\" -f migration.sql; then\",
              \"  echo '✅ Migration applied successfully'\",
              \"else\",
              \"  echo '⚠️  Migration file not found, creating tables manually...'\",
              \"  psql \\\"\\\$DB_URL\\\" <<'EOF'\",
              \"CREATE TABLE IF NOT EXISTS users (\",
              \"  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\",
              \"  email TEXT UNIQUE NOT NULL,\",
              \"  role TEXT NOT NULL DEFAULT 'operator',\",
              \"  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\",
              \");\",
              \"CREATE TABLE IF NOT EXISTS magic_links (\",
              \"  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\",
              \"  email TEXT NOT NULL,\",
              \"  token_hash TEXT NOT NULL,\",
              \"  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\",
              \"  used_at TIMESTAMP WITH TIME ZONE,\",
              \"  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\",
              \");\",
              \"CREATE TABLE IF NOT EXISTS sessions (\",
              \"  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\",
              \"  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\",
              \"  expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\",
              \"  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\",
              \");\",
              \"CREATE TABLE IF NOT EXISTS events (\",
              \"  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\",
              \"  type TEXT NOT NULL,\",
              \"  lead_id UUID,\",
              \"  meta_json JSONB,\",
              \"  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\",
              \");\",
              \"INSERT INTO users (email, role) VALUES ('aaronhenry1981@gmail.com', 'owner') ON CONFLICT (email) DO UPDATE SET role = 'owner';\",
              \"EOF\",
              \"fi\",
              \"echo 'Verifying tables...'\",
              \"TABLES=\\\$(psql \\\"\\\$DB_URL\\\" -t -c \\\"SELECT tablename FROM pg_tables WHERE schemaname = 'public' AND tablename IN ('users', 'magic_links', 'sessions', 'events');\\\" | tr -d ' ')\",
              \"for table in users magic_links sessions events; do\",
              \"  if echo \\\"\\\$TABLES\\\" | grep -q \\\"^\\\$table\\$\"; then\",
              \"    echo \\\"✅ Table \\\$table exists\\\"\",
              \"  else\",
              \"    echo \\\"❌ Table \\\$table missing\\\"\",
              \"    exit 1\",
              \"  fi\",
              \"done\",
              \"echo '✅ All tables verified'\"
            ]" \
            --comment "IFD run RDS migrations" \
            --query "Command.CommandId" \
            --output text)
          
          echo "Waiting for migrations..."
          sleep 15
          
          aws ssm wait command-executed \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" || true
          
          OUTPUT=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)
          
          STATUS=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "Status" \
            --output text)
          
          echo "Migration Status: $STATUS"
          echo "$OUTPUT"
          
          if [[ "$STATUS" != "Success" ]]; then
            ERROR=$(aws ssm get-command-invocation \
              --region us-east-2 \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --query "StandardErrorContent" \
              --output text)
            echo "Error: $ERROR"
            exit 1
          fi

      - name: Restart Container
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
        run: |
          set -euo pipefail
          
          echo "Restarting container..."
          
          CMD_ID=$(aws ssm send-command \
            --region us-east-2 \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"docker restart ifd-app >/dev/null 2>&1 || echo 'Container restart skipped'\",
              \"sleep 10\",
              \"echo 'Checking health endpoint...'\",
              \"for i in {1..12}; do\",
              \"  if curl -fsS http://localhost:3000/health >/dev/null 2>&1; then\",
              \"    echo '✅ Container is healthy'\",
              \"    HEALTH=\\\$(curl -fsS http://localhost:3000/health 2>/dev/null || echo '')\",
              \"    if echo \\\"\\\$HEALTH\\\" | grep -q 'postgres.*connected\\|postgres.*ok' || echo \\\"\\\$HEALTH\\\" | grep -q '\"postgres\":\"ok\"'; then\",
              \"      echo '✅ Database connection verified'\",
              \"    else\",
              \"      echo '⚠️  Container healthy but database status unclear'\",
              \"    fi\",
              \"    break\",
              \"  else\",
              \"    if [ \\\$i -eq 12 ]; then\",
              \"      echo '⚠️  Container not responding after 2 minutes'\",
              \"      docker logs --tail 50 ifd-app 2>&1 | head -20\",
              \"    else\",
              \"      echo 'Waiting... (attempt '\\\$i'/12)'\",
              \"      sleep 10\",
              \"    fi\",
              \"  fi\",
              \"done\"
            ]" \
            --comment "IFD restart after RDS setup" \
            --query "Command.CommandId" \
            --output text)
          
          sleep 15
          
          OUTPUT=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)
          
          echo "$OUTPUT"

      - name: Final Verification
        env:
          INSTANCE_ID: i-0160b2a838a432bbc
        run: |
          set -euo pipefail
          
          echo "=========================================="
          echo "Final Verification"
          echo "=========================================="
          
          # Check SSM parameter exists
          SSM_PARAM="/ironfront/prod/DATABASE_URL"
          if aws ssm get-parameter --name "$SSM_PARAM" --region us-east-2 >/dev/null 2>&1; then
            echo "✅ SSM parameter exists: $SSM_PARAM"
          else
            echo "❌ SSM parameter not found: $SSM_PARAM"
            exit 1
          fi
          
          # Check container health
          CMD_ID=$(aws ssm send-command \
            --region us-east-2 \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="[
              \"curl -fsS http://localhost:3000/health 2>/dev/null && echo '✅ Container is healthy' || echo '❌ Container not responding'\",
              \"docker ps | grep ifd-app && echo '✅ Container is running' || echo '❌ Container not running'\"
            ]" \
            --comment "IFD final verification" \
            --query "Command.CommandId" \
            --output text)
          
          sleep 5
          
          OUTPUT=$(aws ssm get-command-invocation \
            --region us-east-2 \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE_ID" \
            --query "StandardOutputContent" \
            --output text)
          
          echo "$OUTPUT"
          
          echo ""
          echo "=========================================="
          echo "✅ Setup Complete!"
          echo "=========================================="
          echo ""
          echo "RDS Instance: ifd-postgres"
          echo "Endpoint: ${{ steps.rds_instance.outputs.db_endpoint }}"
          echo "SSM Parameter: /ironfront/prod/DATABASE_URL"
          echo ""
          echo "Next: Test login at https://ironfrontdigital.com/login"
          echo "Expected: No DATABASE_URL error, email submit returns success"
